#version 450
layout(local_size_x = 64) in;

// Matches C++ CullingUBO (Renderer.cpp): just 6 planes.
layout(std140, set = 0, binding = 2) uniform UCull {
    vec4 planes[6];
} uCull;

layout(std430, set = 0, binding = 0) readonly buffer Transforms {
    mat4 models[];
} uXform;

layout(std430, set = 0, binding = 1) readonly buffer DrawTransform {
    uint transformIndex[];
} uDraw;

layout(std430, set = 0, binding = 3) readonly buffer MeshBounds {
    vec4 centerRadius[]; // xyz=center, w=radius
} uBounds;

struct DrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(std430, set = 0, binding = 4) writeonly buffer OutCmds {
    DrawIndexedIndirectCommand cmds[];
} uOut;

layout(std430, set = 0, binding = 5) buffer DrawCount {
    uint count;
} uCount;

layout(push_constant) uniform PC {
    uint drawCount;
    uint indexCount;
} pc;

bool sphereInFrustum(vec3 c, float r) {
    for (int i = 0; i < 6; ++i) {
        vec4 p = uCull.planes[i];
        float d = dot(p.xyz, c) + p.w;
        if (d < -r) return false;
    }
    return true;
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= pc.drawCount) return;

    uint tIndex = uDraw.transformIndex[id];

    // Current: single mesh bounds at index 0 (extend later per-draw meshId)
    vec4 cr = uBounds.centerRadius[0];
    vec3 cL = cr.xyz;
    float rL = cr.w;

    mat4 m = uXform.models[tIndex];
    vec3 cW = vec3(m * vec4(cL, 1.0));

    float sx = length(vec3(m[0].xyz));
    float sy = length(vec3(m[1].xyz));
    float sz = length(vec3(m[2].xyz));
    float s = max(sx, max(sy, sz));
    float rW = rL * s;

    bool visible = sphereInFrustum(cW, rW);

    if (!visible) return;

    uint outId = atomicAdd(uCount.count, 1u);
    DrawIndexedIndirectCommand cmd;
    cmd.indexCount = pc.indexCount;
    cmd.instanceCount = 1u;
    cmd.firstIndex = 0u;
    cmd.vertexOffset = 0;
    cmd.firstInstance = tIndex;

    uOut.cmds[outId] = cmd;
}
